package hello.jdbc;

public class Etc {

    // 메모장 22.9.29

    // 트랜잭션 ACID
    // 트랜잭션은 ACID(http://en.wikipedia.org/wiki/ACID)라하는원자성(Atomicity), 일관성 (Consistency), 격리성(Isolation), 지속성(Durability)을보장해야한다.

    // 원자성: 트랜잭션내에서실행한작업들은마치하나의작업인것처럼모두성공하거나모두실패해야 한다.
    // 일관성: 모든트랜잭션은일관성있는데이터베이스상태를유지해야한다. 예를들어데이터베이스에서 정한무결성제약조건을항상만족해야한다.
    // 격리성: 동시에실행되는트랜잭션들이서로에게영향을미치지않도록격리한다. 예를들어동시에같은 데이터를수정하지못하도록해야한다. 격리성은동시성과관련된성능이슈로인해트랜잭션격리수준 (Isolation level)을선택할수있다.
    // 지속성: 트랜잭션을성공적으로끝내면그결과가항상기록되어야한다. 중간에시스템에문제가발생해도 데이터베이스로그등을사용해서성공한트랜잭션내용을복구해야한다.

    // 트랜잭션은원자성, 일관성, 지속성을보장한다.
    // 문제는격리성인데트랜잭션간에격리성을완벽히 보장하려면트랜잭션을거의순서대로실행해야한다.
    // 이렇게하면동시처리성능이매우나빠진다. 이런 문제로인해 ANSI 표준은트랜잭션의격리수준을 4단계로나누어정의했다.

    // 트랜잭션격리수준 -
    // Isolation level READ UNCOMMITED(커밋되지않은읽기)
    // READ COMMITTED(커밋된읽기)
    // REPEATABLE READ(반복가능한읽기)
    // SERIALIZABLE(직렬화가능)
    
    //  22.9.30 메모
    //  트랜젝션의 문제점 3가지
    //  트랜잭션 문제
    //  예외누수문제
    //  JDBC의 문제

    // 트랜잭션의 문제
    //  JDBC 구현기술이서비스계층에누수되는문제
    //  트랜잭션을적용하기위해 JDBC 구현기술이서비스계층에누수되었다.
    //  서비스계층은순수해야한다.     구현기술을변경해도서비스계층코드는최대한유지할수있어야 한다. (변화에대응)
    //  그래서데이터접근계층에 JDBC 코드를다몰아두는것이다.
    //  물론데이터접근계층의구현기술이변경될수도있으니데이터접근계층은인터페이스를 제공하는것이좋다.
    //  서비스계층은특정기술에종속되지않아야한다. 지금까지그렇게노력해서데이터접근계층으로 JDBC 관련코드를모았는데, 트랜잭션을적용하면서결국서비스계층에 JDBC 구현기술의누수가 발생했다.
    //  트랜잭션동기화문제
    //  같은트랜잭션을유지하기위해커넥션을파라미터로넘겨야한다.
    //  이때파생되는문제들도있다. 똑같은기능도트랜잭션용기능과트랜잭션을유지하지않아도되는 기능으로분리해야한다.
    //  트랜잭션적용반복문제
    //  트랜잭션적용코드를보면반복이많다. try, catch, finally

    // 예외 누수 문제
    //  데이터접근계층의 JDBC 구현기술예외가서비스계층으로전파된다.
    //  SQLException은체크예외이기때문에데이터접근계층을호출한서비스계층에서해당예외를잡아서 처리하거나명시적으로throws를통해서다시밖으로던져야한다.
    //  SQLException은 JDBC 전용기술이다.
    //  향후 JPA나다른데이터접근기술을사용하면, 그에맞는다른 예외로변경해야하고, 결국서비스코드도수정해야한다.

    //  JDBC 반복 문제
    //  지금까지작성한MemberRepository 코드는순수한 JDBC를사용했다.
    //  이코드들은유사한코드의반복이너무많다.
    //  try, catch, finally ...
    //  커넥션을열고, PreparedStatement를사용하고, 결과를매핑하고... 실행하고, 커넥션과리소스를 정리한다.

    // 10.05 메모
    //  트랜잭션문제해결 - 트랜잭션 AOP 이해
    //  지금까지 트랜잭션을 편리하게 처리하기 위해서 트랜잭션 추상화도 도입하고, 추가로
    //  반복적인 트랜잭션 로직을 해결하기 위해 트랜잭션 템플릿도 도입했다.
    //  트랜잭션 템플릿 덕분에 트랜잭션을 처리하는 반복 코드는 해결할 수 있다.

    //  프록시를 사용하면 트랜잭션을 처리하는 객체와 비즈니스 로직을 처리하는 서비스 객체를 명확하게 분리할수있다.
    //  프록시도입전: 서비스에비즈니스로직과트랜잭션처리로직이함께섞여있다.
    //  프록시도입후: 트랜잭션프록시가트랜잭션처리로직을모두가져간다. 그리고트랜잭션을시작한후에 실제서비스를대신호출한다.
    //   트랜잭션프록시덕분에서비스계층에는순수한비즈니즈로직만남길수있다.

    //  스프링이제공하는트랜잭션 AOP
    //  개발자는 트랜잭션 처리가 필요한곳에 @Transactional 애노테이션만 붙여주면된다.
    //  스프링의 트랜잭션 AOP는이애노테이션을인식해서트랜잭션프록시를적용해준다.


    //  10.10 메모
    //  체크예외의문제점
    //  체크예외는컴파일러가예외누락을체크해주기때문에개발자가실수로예외를놓치는것을막아준다.
    //  그래서항상명시적으로예외를잡아서처리하거나,
    //  처리할수없을때는예외를던지도록method() throws 예외로선언해야한다.

    //  리포지토리는 DB에접근해서데이터를저장하고관리한다. 여기서는SQLException 체크예외를던진다.
    //  NetworkClient는외부네트워크에접속해서어떤기능을처리하는객체이다. 여기서는 ConnectException 체크예외를던진다.

    //  서비스는리포지토리와NetworkClient를둘다호출한다.
    //  따라서두곳에서올라오는체크예외인SQLException과ConnectException을처리해야한다.
    //  그런데서비스는이둘을처리할방법을모른다.
    //  ConnectException처럼연결이실패하거나, SQLException 처럼데이터베이스에서발생하는문제처럼심각한문제들은대부분애플리케이션 로직에서처리할방법이없다.

    //  서비스는 SQLException과ConnectException를처리할수없으므로둘다밖으로던진다.
    //  체크예외이기때문에던질경우다음과같이선언해야한다.
    //  method() throws SQLException, ConnectException

    //  컨트롤러도두예외를처리할방법이없다.
    //  다음을선언해서예외를밖으로던진다.
    //  method() throws SQLException, ConnectException.

    //  웹애플리케이션이라면서블릿의오류페이지나, 또는스프링 MVC가제공하는ControllerAdvice에서 이런예외를공통으로처리한다.
    //  이런문제들은보통사용자에게어떤문제가발생했는지자세히설명하기가어렵다. 그래서
    //  사용자에게는 "서비스에문제가있습니다." 라는일반적인메시지를보여준다. ("데이터베이스에어떤 오류가발생했어요" 라고알려주어도일반사용자가이해할수없다. 그리고보안에도문제가될수 있다.)
    //  API라면보통 HTTP 상태코드 500(내부서버오류)을사용해서응답을내려준다.
    //  이렇게해결이불가능한공통예외는별도의오류로그를남기고, 개발자가오류를빨리인지할수 있도록메일, 알림(문자, 슬랙)등을통해서전달받아야한다.
    //  예를들어서SQLException이잘못된 SQL을작성해서발생했다면, 개발자가해당 SQL을수정해서배포하기전까지사용자는같은문제를 겪게된다

    /** 예외 포함과 스택 트레이스
     *  예외를전환할때는 꼭! 기존예외를포함해야한다. 그렇지않으면스택트레이스를확인할때심각한 문제가발생한다.
     *  예시 )
     *  @Test
     *  void printEx() {
     *  Controller controller = new Controller();
     *  try {
     *         controller.request();
     *  } catch (Exception e) {
     *      //e.printStackTrace();
     *         log.info("ex", e);
     *       }
     *  }
     * **/
    //  로그를출력할때마지막파라미터에예외를넣어주면로그에스택트레이스를출력할수있다.
    //  예) log.info("message={}", "message", ex), 여기에서마지막에ex를전달하는것을확인할 수있다. 이렇게하면스택트레이스에로그를출력할수있다.
    //  예) log.info("ex", ex) 지금예에서는파라미터가없기때문에, 예외만파라미터에전달하면스택 트레이스를로그에출력할수있다.
    //  System.out에스택트레이스를출력하려면e.printStackTrace()를사용하면된다.
    // 실무에서는 항상 로그를 사용해야한다.

    /** 기존 예외를 포함하는 경우
     *  public void call() {
     *   try {
     *  runSQL();
     *      } catch (SQLException e) {
     *      throw new RuntimeSQLException(e); //기존 예외(e) 포함 }
     *  }
     * **/
    // 예외를 포함해서 기존에 발생한 java.sql.SQLException 과 스택 트레이스르 확인할 수 있다.

    /** 기존 예외를 포함하지 않는 경우
     *  public void call() {
     *       try {
     *      runSQL();
     *      } catch (SQLException e) {
     *       throw new RuntimeSQLException(); //기존 예외(e) 제외
     *     }
     *  }
     * **/
    //  예외를포함하지않아서기존에발생한java.sql.SQLException과스택트레이스를확인할수없다.
    //  변환한RuntimeSQLException부터예외를확인할수있다.
    //  만약실제 DB에연동했다면 DB에서발생한 예외를확인할수없는심각한문제가발생한다.
    // 예외를 전환할 떄는 꼭 기존 예외를 포함시키자 . 제발 !!!
}
