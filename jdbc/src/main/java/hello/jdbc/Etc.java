package hello.jdbc;

public class Etc {

    // 메모장 22.9.29
    // 트랜잭션 ACID
    // 트랜잭션은 ACID(http://en.wikipedia.org/wiki/ACID)라하는원자성(Atomicity), 일관성 (Consistency), 격리성(Isolation), 지속성(Durability)을보장해야한다.

    // 원자성: 트랜잭션내에서실행한작업들은마치하나의작업인것처럼모두성공하거나모두실패해야 한다.
    // 일관성: 모든트랜잭션은일관성있는데이터베이스상태를유지해야한다. 예를들어데이터베이스에서 정한무결성제약조건을항상만족해야한다.
    // 격리성: 동시에실행되는트랜잭션들이서로에게영향을미치지않도록격리한다. 예를들어동시에같은 데이터를수정하지못하도록해야한다. 격리성은동시성과관련된성능이슈로인해트랜잭션격리수준 (Isolation level)을선택할수있다.
    // 지속성: 트랜잭션을성공적으로끝내면그결과가항상기록되어야한다. 중간에시스템에문제가발생해도 데이터베이스로그등을사용해서성공한트랜잭션내용을복구해야한다.

    // 트랜잭션은원자성, 일관성, 지속성을보장한다.
    // 문제는격리성인데트랜잭션간에격리성을완벽히 보장하려면트랜잭션을거의순서대로실행해야한다.
    // 이렇게하면동시처리성능이매우나빠진다. 이런 문제로인해 ANSI 표준은트랜잭션의격리수준을 4단계로나누어정의했다.

    // 트랜잭션격리수준 -
    // Isolation level READ UNCOMMITED(커밋되지않은읽기)
    // READ COMMITTED(커밋된읽기)
    // REPEATABLE READ(반복가능한읽기)
    // SERIALIZABLE(직렬화가능)
    
    //  22.9.30 메모
    //  트랜젝션의 문제점 3가지
    //  트랜잭션 문제
    //  예외누수문제
    //  JDBC의 문제

    // 트랜잭션의 문제
    //  JDBC 구현기술이서비스계층에누수되는문제
    //  트랜잭션을적용하기위해 JDBC 구현기술이서비스계층에누수되었다.
    //  서비스계층은순수해야한다.     구현기술을변경해도서비스계층코드는최대한유지할수있어야 한다. (변화에대응)
    //  그래서데이터접근계층에 JDBC 코드를다몰아두는것이다.
    //  물론데이터접근계층의구현기술이변경될수도있으니데이터접근계층은인터페이스를 제공하는것이좋다.
    //  서비스계층은특정기술에종속되지않아야한다. 지금까지그렇게노력해서데이터접근계층으로 JDBC 관련코드를모았는데, 트랜잭션을적용하면서결국서비스계층에 JDBC 구현기술의누수가 발생했다.
    //  트랜잭션동기화문제
    //  같은트랜잭션을유지하기위해커넥션을파라미터로넘겨야한다.
    //  이때파생되는문제들도있다. 똑같은기능도트랜잭션용기능과트랜잭션을유지하지않아도되는 기능으로분리해야한다.
    //  트랜잭션적용반복문제
    //  트랜잭션적용코드를보면반복이많다. try, catch, finally

    // 예외 누수 문제
    //  데이터접근계층의 JDBC 구현기술예외가서비스계층으로전파된다.
    //  SQLException은체크예외이기때문에데이터접근계층을호출한서비스계층에서해당예외를잡아서 처리하거나명시적으로throws를통해서다시밖으로던져야한다.
    //  SQLException은 JDBC 전용기술이다.
    //  향후 JPA나다른데이터접근기술을사용하면, 그에맞는다른 예외로변경해야하고, 결국서비스코드도수정해야한다.

    //  JDBC 반복 문제
    //  지금까지작성한MemberRepository 코드는순수한 JDBC를사용했다.
    //  이코드들은유사한코드의반복이너무많다.
    //  try, catch, finally ...
    //  커넥션을열고, PreparedStatement를사용하고, 결과를매핑하고... 실행하고, 커넥션과리소스를 정리한다.

    // 10.05 메모
    //  트랜잭션문제해결 - 트랜잭션 AOP 이해
    //  지금까지 트랜잭션을 편리하게 처리하기 위해서 트랜잭션 추상화도 도입하고, 추가로
    //  반복적인 트랜잭션 로직을 해결하기 위해 트랜잭션 템플릿도 도입했다.
    //  트랜잭션 템플릿 덕분에 트랜잭션을 처리하는 반복 코드는 해결할 수 있다.

    //  프록시를 사용하면 트랜잭션을 처리하는 객체와 비즈니스 로직을 처리하는 서비스 객체를 명확하게 분리할수있다.
    //  프록시도입전: 서비스에비즈니스로직과트랜잭션처리로직이함께섞여있다.
    //  프록시도입후: 트랜잭션프록시가트랜잭션처리로직을모두가져간다. 그리고트랜잭션을시작한후에 실제서비스를대신호출한다.
    //   트랜잭션프록시덕분에서비스계층에는순수한비즈니즈로직만남길수있다.

    //  스프링이제공하는트랜잭션 AOP
    //  개발자는 트랜잭션 처리가 필요한곳에 @Transactional 애노테이션만 붙여주면된다.
    //  스프링의 트랜잭션 AOP는이애노테이션을인식해서트랜잭션프록시를적용해준다.






}
